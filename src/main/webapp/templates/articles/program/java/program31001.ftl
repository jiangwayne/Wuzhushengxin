<div class="article-body">
    <p>java是一种强类型语言,必须为每一个变量声明一种类型。java中,一共有8种基本类型</p>
    <h5>一.整型</h5>
    <p>java提供了4种整型,允许表示负数,java不提供任何无符号的类型</p>
    <table class="table">
        <thead>
            <tr>
                <th>类型</th>
                <th>占用存储空间</th>
                <th>取值范围</th>
            </tr>
        </thead>
        <tbody>
            <tr>
                <td>byte</td>
                <td>1字节</td>
                <td>-128~127</td>
            </tr>
            <tr>
                <td>short</td>
                <td>2字节</td>
                <td>-32,768~32767</td>
            </tr>
            <tr>
                <td>int</td>
                <td>4字节</td>
                <td>-2,147,483,648~2,147,483,647</td>
            </tr>
            <tr>
                <td>long</td>
                <td>8字节</td>
                <td>-9,223,372,036,854,775,808~9,223,372,036,854,775,807</td>
            </tr>
        </tbody>
    </table>
    <p style="color: #ff0000;">为什么byte的取值范围是-128~127呢?&nbsp;先了解原码, 反码和补码的概念</p>
    <p>
        原码:符号位加上真值的绝对值, 即用第一位表示符号(0表示正,1表示负), 其余位表示值. 比如8位二进制:<br />
        1&nbsp;=0000&nbsp;0001<br/>
        -1=1000&nbsp;0001<br/>
        显然我们的0占了两个原码0000&nbsp;0000与1000&nbsp;0000,于示256个原码只能表示255个数字
        所以8位二进制原码的取值范围是[1111&nbsp;11111,0111&nbsp;1111],即[-127 , 127]<br/>
    </p>
    <p>
        反码:正数的反码是其本身,负数的反码是在其原码的基础上, 符号位不变，其余各个位取反<br/>
        1&nbsp;=0000&nbsp;0001(原)=0000&nbsp;0001(反)<br/>
        -1=1000&nbsp;0001(原)=1111&nbsp;1110(反)<br/>
        显然我们的0还是占了两个反码0000&nbsp;0000与1111&nbsp;1111<br/>
    </p>
    <p>
        补码:正数的补码就是其本身,负数的补码是在其原码的基础上, 符号位不变, 其余各位取反, 最后+1. (即在反码的基础上+1)<br/>
        1&nbsp;=0000&nbsp;0001(原)=0000&nbsp;0001(反)=0000&nbsp;0001(补)<br/>
        -1=1000&nbsp;0001(原)=1111&nbsp;1110(反)=1111&nbsp;1111(补码)<br/>
        +0=0000&nbsp;0000(原)=0000&nbsp;0000(反)=0000&nbsp;0000(补)<br/>
        -0=1000&nbsp;0000(原)=1111&nbsp;1111(反)=0000&nbsp;0000(补)(反码+1,溢出,进位1被丢弃)<br/>
        -127=1111&nbsp;1111(原)=1000&nbsp;0000(反)=1000&nbsp;0001(补)<br/>
        于是0的补码只有一个,那么多出来的1000&nbsp;0000(补)用来表示-128, 这也符合用补码做加法运算-128+1=-127,再看下面的运算<br/>
        5-3=5+(-3)=0000&nbsp;0101(补)+1111&nbsp;1101(补)=1111&nbsp;1101(补)=0000&nbsp;0010(补)(溢出,进位1被丢弃)=2<br/>
        就这样,补码神奇的解决了0占用两个编码的问题,还能多表示一个最低数, 并且能将减法运算统一按加法来处理,简化了计算机运算单元的
        设计(不需要去识别正负,只做加法,溢出就丢弃)、减小晶圆面积、降低散热...
    </p>
    <h5>二.浮点类型</h5>
    <table class="table">
        <thead>
        <tr>
            <th>类型</th>
            <th>占用存储空间</th>
            <th>取值范围</th>
        </tr>
        </thead>
        <tbody>
        <tr>
            <td>float</td>
            <td>4</td>
            <td>-3.4028235E38~3.4028235E38(3.4028235乘以10的38次方)</td>
        </tr>
        <tr>
            <td>double</td>
            <td>8字节</td>
            <td>~7976931348623157E308-324~7976931348623157E308</td>
        </tr>
        </tbody>
    </table>
    <p>
        所有浮点数值计算都遵循IEEE&nbsp;754规范<br/>
        一个float4字节32位,分为三部分：符号位(1bit)，指数位(8bit)，尾数位(23bit)<br/>
        一个double8字节(共64位),分为三部分：符号位(1bit)，指数位(11bit)，尾数位(52bit)<br/>
        因为小数有无穷多个,浮点数都是有精度的，并不能表示绝对值任意小的值<br/>
    </p>
    <pre>
        <code class="java">
float a = 0.00000000000003741923741263f;
System.out.println(a); //3.741924E-14
a=0.00500000000003741923741263f;
System.out.println(a); //0.005a=a-0.005f;
System.out.println(a); //0.0
        </code>
    </pre>
    <h5>三.字符类型</h5>
    <p>在java中,char类型描述了UTF-16编码中的一个代码单元,所以占2个字节</p>
    <h5>四.boolean类型</h5>
    <p>
        java中boolean类型有两个值,true和false,用来判定逻辑条件,整型值和boolean值之间不能进行相互转换
    </p>
</div>